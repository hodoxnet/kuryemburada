// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SUPER_ADMIN
  COMPANY
  COURIER
}

enum UserStatus {
  ACTIVE
  INACTIVE
  BLOCKED
  PENDING
}

enum CompanyStatus {
  PENDING
  APPROVED
  REJECTED
  ACTIVE
  INACTIVE
}

enum CourierStatus {
  PENDING
  APPROVED
  REJECTED
  ACTIVE
  INACTIVE
  BUSY
}

enum OrderStatus {
  PENDING
  ACCEPTED
  IN_PROGRESS
  DELIVERED
  CANCELLED
  REJECTED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  BANK_TRANSFER
}

enum PackageType {
  DOCUMENT
  PACKAGE
  FOOD
  OTHER
}

enum PackageSize {
  SMALL
  MEDIUM
  LARGE
  EXTRA_LARGE
}

enum Urgency {
  NORMAL
  URGENT
  VERY_URGENT
}

enum DeliveryType {
  STANDARD
  EXPRESS
}

enum DocumentType {
  TRADE_LICENSE
  TAX_CERTIFICATE
  KEP_ADDRESS
  IDENTITY_CARD
  DRIVER_LICENSE
  VEHICLE_REGISTRATION
  INSURANCE
  ADDRESS_PROOF
  CRIMINAL_RECORD
  HEALTH_REPORT
  TAX_PLATE
  OTHER
}

enum DocumentStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationType {
  ORDER_CREATED
  ORDER_ACCEPTED
  ORDER_REJECTED
  ORDER_DELIVERED
  ORDER_CANCELLED
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  ACCOUNT_APPROVED
  ACCOUNT_REJECTED
  SYSTEM
}

enum ReconciliationStatus {
  PENDING
  PAID
  PARTIALLY_PAID
  OVERDUE
}

enum CompanyPaymentType {
  DAILY_RECONCILIATION
  MANUAL_PAYMENT
  REFUND
  ADJUSTMENT
}

enum OrderSource {
  MANUAL
  YEMEKSEPETI
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  password  String
  role      UserRole
  status    UserStatus @default(PENDING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  company       Company?
  courier       Courier?
  notifications Notification[]
  refreshTokens RefreshToken[]
}

model Company {
  id             String        @id @default(uuid())
  userId         String        @unique
  name           String
  taxNumber      String?       @unique
  taxOffice      String?
  kepAddress     String?
  phone          String
  address        Json // {city, district, neighborhood, street, detail}
  bankInfo       Json? // {bankName, iban, accountHolder}
  contactPerson  Json? // {name, phone, email, title}
  activityArea   String?
  tradeLicenseNo String?
  defaultPackageType PackageType? // Firma varsayılan gönderi tipi
  status         CompanyStatus @default(PENDING)
  approvalReason String?
  rejectionReason String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders    Order[]
  documents Document[]
  balance   CompanyBalance?
  reconciliations DailyReconciliation[]
  payments  CompanyPayment[]
  yemeksepetiVendors YemeksepetiVendor[]
}

model Courier {
  id                String        @id @default(uuid())
  userId            String        @unique
  tcNumber          String        @unique
  fullName          String
  birthDate         DateTime?
  phone             String
  licenseInfo       Json? // {class, issueDate, expiryDate, number}
  vehicleInfo       Json? // {plate, brand, model, year, registrationNo}
  insuranceInfo     Json? // {company, policyNo, expiryDate}
  bankInfo          Json? // {bankName, iban, accountHolder}
  emergencyContact  Json? // {name, phone, relationship}
  status            CourierStatus @default(PENDING)
  currentLocation   Json? // {lat, lng, lastUpdate}
  isAvailable       Boolean       @default(true)
  approvalReason    String?
  rejectionReason   String?
  rating            Float?        @default(0)
  totalDeliveries   Int           @default(0)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders    Order[]
  documents Document[]
}

model Order {
  id               String        @id @default(uuid())
  orderNumber      String        @unique
  companyId        String
  courierId        String?
  pricingRuleId    String?
  serviceAreaId    String?       // Hangi bölgedeki sipariş
  recipientName    String
  recipientPhone   String
  pickupAddress    Json // {lat, lng, address, detail}
  deliveryAddress  Json // {lat, lng, address, detail}
  packageType      PackageType
  packageSize      PackageSize
  urgency          Urgency       @default(NORMAL)
  deliveryType     DeliveryType  @default(STANDARD)
  scheduledPickupTime DateTime?  // İleri tarih/saat planlama için
  notes            String?
  distance         Float? // in km
  estimatedTime    Int? // in minutes
  price            Float
  commission       Float? // platform commission
  courierEarning   Float? // courier earning after commission
  status           OrderStatus   @default(PENDING)
  source           OrderSource   @default(MANUAL) // Sipariş kaynağı
  acceptedAt       DateTime?
  pickedUpAt       DateTime?
  deliveredAt      DateTime?
  cancelledAt      DateTime?
  cancellationReason String?
  deliveryProof    String? // photo url or signature
  rating           Int? // 1-5
  feedback         String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  company     Company      @relation(fields: [companyId], references: [id])
  courier     Courier?     @relation(fields: [courierId], references: [id])
  pricingRule PricingRule? @relation(fields: [pricingRuleId], references: [id])
  serviceArea ServiceArea? @relation(fields: [serviceAreaId], references: [id])
  payments    Payment[]
  yemeksepetiOrder YemeksepetiOrder?
}

model Payment {
  id            String        @id @default(uuid())
  orderId       String
  amount        Float
  paymentMethod PaymentMethod
  status        PaymentStatus @default(PENDING)
  transactionId String?
  paidAt        DateTime?
  refundedAt    DateTime?
  refundReason  String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  order Order @relation(fields: [orderId], references: [id])
}

model Document {
  id          String         @id @default(uuid())
  entityType  String // 'company' or 'courier'
  entityId    String?
  companyId   String?
  courierId   String?
  type        DocumentType
  documentType DocumentType?
  fileUrl     String
  fileName    String
  fileSize    Int? // in bytes
  mimeType    String?
  status      DocumentStatus @default(PENDING)
  verifiedBy  String? // admin user id
  verifiedAt  DateTime?
  rejectionReason String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  company Company? @relation(fields: [companyId], references: [id])
  courier Courier? @relation(fields: [courierId], references: [id])
}

model YemeksepetiVendor {
  id                   String   @id @default(uuid())
  companyId            String
  remoteId             String   @unique
  posVendorId          String
  chainCode            String
  brandCode            String?
  platformRestaurantId String?
  pickupAddress        Json?
  isActive             Boolean  @default(true)
  clientId             String?
  clientSecret         String?
  inboundToken         String?
  tokenUrl             String?
  baseUrl              String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id])
  orders  YemeksepetiOrder[]

  @@index([companyId])
}

model YemeksepetiOrder {
  id            String   @id @default(uuid())
  vendorId      String
  orderId       String?  @unique
  token         String
  code          String
  remoteOrderId String
  status        String   @default("dispatched")
  payload       Json
  callbackUrls  Json?
  rejectionReason String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  vendor YemeksepetiVendor @relation(fields: [vendorId], references: [id])
  order  Order?            @relation(fields: [orderId], references: [id])

  @@index([vendorId])
  @@index([remoteOrderId])
}

model PricingRule {
  id                String   @id @default(uuid())
  name              String   @unique
  description       String?
  serviceAreaId     String?  // Bölgeye özel fiyatlandırma
  basePrice         Float    @default(0)
  pricePerKm        Float    @default(0)
  pricePerMinute    Float    @default(0)
  minimumPrice      Float    @default(0)
  rushHourMultiplier Float?  @default(1)
  weatherMultiplier Float?   @default(1)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  serviceArea       ServiceArea? @relation(fields: [serviceAreaId], references: [id])
  orders            Order[]
}

model RefreshToken {
  id           String   @id @default(uuid())
  userId       String
  tokenHash    String   @unique
  family       String   // Token family for rotation tracking
  expiresAt    DateTime
  isRevoked    Boolean  @default(false)
  revokedAt    DateTime?
  revokedReason String? // logout, password_change, suspicious_activity
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([tokenHash])
  @@index([userId])
  @@index([family])
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType @default(SYSTEM)
  title     String
  message   String
  content   String?
  data      Json? // additional data
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SystemSetting {
  id          String   @id @default(uuid())
  key         String   @unique
  value       Json
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ServiceArea {
  id          String   @id @default(uuid())
  name        String   @unique // Örn: "Beylikdüzü", "Avcılar"
  city        String   // Örn: "İstanbul"
  district    String   // İlçe adı
  boundaries  Json     // Poligon koordinatları: [{lat, lng}, ...]
  basePrice   Float    // Bu bölge için taban fiyat
  pricePerKm  Float    // Bu bölge için km başı fiyat
  maxDistance Float?   // Maksimum teslimat mesafesi (km)
  isActive    Boolean  @default(true)
  priority    Int      @default(0) // Öncelik sırası (büyük olan önce kontrol edilir)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  orders      Order[]  // Bu bölgedeki siparişler
  pricingRules PricingRule[] // Bu bölgeye özel fiyatlandırma kuralları
  
  @@index([city, district])
  @@index([isActive])
}

model AuditLog {
  id         String   @id @default(uuid())
  userId     String?
  action     String
  entity     String
  entityId   String?
  oldData    Json?
  newData    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
}

model CompanyBalance {
  id              String   @id @default(uuid())
  companyId       String   @unique
  currentBalance  Float    @default(0) // Firma'nın borcu (pozitif = borç, negatif = alacak)
  totalDebts      Float    @default(0) // Toplam borç
  totalCredits    Float    @default(0) // Toplam alacak (ödemeler)
  lastPaymentDate DateTime?
  lastPaymentAmount Float?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model DailyReconciliation {
  id                String               @id @default(uuid())
  companyId         String
  date              DateTime             @db.Date // Mutabakat tarihi
  totalOrders       Int                  @default(0) // Gün içindeki toplam sipariş sayısı
  deliveredOrders   Int                  @default(0) // Teslim edilen sipariş sayısı
  cancelledOrders   Int                  @default(0) // İptal edilen sipariş sayısı
  totalAmount       Float                @default(0) // Toplam tutar
  courierCost       Float                @default(0) // Kurye maliyeti
  platformCommission Float               @default(0) // Platform komisyonu
  netAmount         Float                @default(0) // Net borç (totalAmount - platformCommission)
  status            ReconciliationStatus @default(PENDING)
  paidAmount        Float                @default(0) // Ödenen tutar
  remainingAmount   Float                @default(0) // Kalan borç
  notes             String?
  reconciledBy      String?              // Admin user id
  reconciledAt      DateTime?
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  @@unique([companyId, date]) // Her gün için bir mutabakat
  @@index([date])
  @@index([status])
}

model CompanyPayment {
  id                   String             @id @default(uuid())
  companyId            String
  reconciliationId     String?            // İlgili mutabakat kaydı
  paymentType          CompanyPaymentType
  amount               Float
  paymentMethod        PaymentMethod
  transactionReference String?            // Banka dekont no, işlem referansı vb.
  description          String?
  processedBy          String?            // Admin user id
  processedAt          DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([reconciliationId])
  @@index([paymentType])
}

model Province {
  id        String     @id @default(uuid())
  name      String     @unique
  plateCode String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  districts District[]

  @@index([name])
  @@index([plateCode])
}

model District {
  id         String   @id @default(uuid())
  name       String
  provinceId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  province Province @relation(fields: [provinceId], references: [id], onDelete: Cascade)

  @@unique([name, provinceId])
  @@index([provinceId])
  @@index([name])
}
